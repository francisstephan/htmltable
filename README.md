# Basic rust command line skills: arguments, files and String management

`htmltable` is a small tool I built for fun and out of pure lazyness (it's so boring to write html tables by hand...).
Through CSV, the tool also allows to convert between excel and html tables.

The html to csv part is a bit tricky; I do accept that `<table..`, `<tr..` and `<td..` tags may have some class or id or anything included, but I suppose that `</table>, </tr> and </td>` are present under this form. Also tags should be in lower case (`<tr>`, not `<TR>`). The parse will stop if invalid html is detected - but possibly some output will have been generated by that time, so check both the input and the output files. The program is not an html validity checker.

After a brief description of what the program does, I shall present three basic skills for rust command line programming: parsing arguments, reading and writing files, and using strings.

## 1. Program description
If you download the program and run it with `cargo run -- -h` , you will get the following text:

Program to build an html table from a list of lines with optional separator

and conversely to convert html table to CSV (using comma or any separator character)

Usage: htmltable [OPTIONS] --input `<INPUT>` --output `<OUTPUT>`

Options:

  -i, --input `<INPUT>`        : Path of input file, relative to current path

  -o, --output `<OUTPUT>`        : Path of output file, relative to current path

  -s, --separator `<SEPARATOR>`  : Character to be used as separator in lines of input file [default: ' ']

  -r, --reverse                : Reverse mode (html to plain text with separator), default=false

  -h, --help                   : Print help

  -V, --version                : Print version

Concerning the separator character (',' for CSV), make sure that this separator is not present in the cell text...


## Example:
One sample file romaji.txt is provided

To test the program, try:

cargo run -- -i romaji.txt -o romaji.html

(using the default ' ', single space, as separator; in this case two adjacent spaces in a row mean one empty cell)


Then try to convert the resulting file to CSV:

cargo run -- -i romaji.html -o romaji.csv -s , -r

I used romaji.html, together with some CSS, in my [hkana program](https://eludev.fr/hkana/)

## 2. Parsing arguments: the `clap` crate
There are many `clap` tutorials out there, but the following should be enough to get you started.
First, include the crate in your Cargo.toml:
```bash
cargo add clap
```
Then define a name for each argument: in my case there were 4 :
input (of type String), output (also a String), separator (a char) and reverse (a bool, meaning if -r or --reverse is in the argument list, reverse will be `true`, otherwise it will be `false`).

To define them as arguments with clap is very easy:
```rust
use clap::Parser;

/// Program to build an html table from a list of lines with optional separator
/// and conversely to convert html table to CSV (using comma or any separator character)
#[derive(Parser, Debug)]
#[command(version)]
struct Args {
    /// Path of input file, relative to current path
    #[arg(short, long)]
    input: String,

    /// Path of output file, relative to current path
    #[arg(short, long)]
    output: String,

    /// Character to be used as separator inside lines of input file
    #[arg(short, long, default_value_t = ' ')]
    separator: char,

    /// Reverse mode (html to plain text with separator), default=false
    #[arg(short, long, default_value_t = false)]
    reverse: bool,
}

fn main() {
    let args = Args::parse();
```
Within the `Args` struct, the `Ã¬nput` item for instance is a rust variable of type String, and is also the name of the corresponding argument in the argument list.

The comments with 3 / are called 'doc comments': when you call `yourProgram -h` or `yourProgram --help` you will get exactly the text given in section 1 herabove. In addition to the 4 arguments (-i or --input, -o or --output, -s or --separator and -r or --reverse) clap will give you as a bonus 2 arguments (-V or --version, for which you must provide the `#[command(version)]` line), -h or --help).

-V will take its data from Cargo.toml, while -h will use the doc comments you provided.

In main() you get the actual argument values with `Args::parse`.

## 3. Basic file reading and writing
### 3.1 Read from a text file:
There is an `open` instruction, but for simple cases you don't need it, just use `read_to_string`to read from a file with path (absolute or relative) `filename` :
```rust
use std::fs::read_to_string;
let readresult: Vec<String> = read_to_string(filename)
        .expect("Failed to read input file") // print message, then panic
        .lines() // split the string into an iterator of string slices Lines<'_>
        .map(String::from) // make each slice into a string
        .collect() // transform Lines<'_> into a Vec<String>
```
There is no `close` instruction: a file gets closed when it gets out of scope - or when a panic occurs.

To check if file named `some_file_name` exists, do:
```rust
use std::path::Path;

if !Path::new("some_file_name").exists() {
    println!("Error: file some_file_name does not exist");
    return;
}
```

### 3.2 Write to a text file

To write to a text file, first open it with `create` :
```rust
use std::fs::File;

let mut ofil = File::create(outfile).expect("Cannot create output file");
```
outfile is an &str with the path (relative or absolute) of the file.

If the file does not exist, it will be created; otherwise it will be truncated.

For other cases, use OpenOptions [https://doc.rust-lang.org/std/fs/struct.OpenOptions.html](https://doc.rust-lang.org/std/fs/struct.OpenOptions.html)

To write a string ended with a line feed, do:
```rust
writeln!(ofil, "<table class='rustgen'>").expect("Cannot write to file");
```
To write several elements followed by a line feed, do:
```rust
for cell in cells {
    write!(ofil, "<td>{}</td>", cell).expect("Cannot write cell to file");
}
writeln!(ofil, "").expect("Cannot write to file"); // add line feed (writeln)
```
`write!` and `writeln!` are two macros, with the same syntax as the `print!` and `println!` macros.

Again, no need to explictly close the file.

## 4. Working with String

String is a big subject in rust, I shall just explain what I use in the program. Please refer to the full listing of the program starting with line 80.

### 4.1 find() and get() :
Look at the following code (line 82):
```rust
// 1. read infile as a String:
let mut content = read_to_string(infile).expect("Failed to read input file");

// 2. eliminate anything before <table..
if let Some(i) = content.find("<table") {
    content = content.get(i..).unwrap().to_string();
```
`content` is a mutable String, which we read from the infile file. It is supposed to containe the whole html table which we want to parse.

The `find(t:&str)` function returns the index of the first ocurrence of t within the string, or `None` if t is not present.

The `get(i..)` function returns a reference (&str) to the part of String starting with i until the end, or None if i is out of range. Here I can safely use unwrap() since I know that i is within the range (0<= i < content.len())

Similarly, the following code shows the use of `get(..i)` :
```rust
// 3. eliminate anything after </table> (including the </table> tag)
if let Some(i) = content.find("</table>") {
    content = content.get(..i).unwrap().to_string();
```
### 4.2 replace() :

The signature of the replace function is:
```rust
pub fn replace<P>(&self, from: P, to: &str) -> String
```
P is a Pattern, which is a Trait which is satisfied by several types, including &str, as in our code (line 104-105 of htmltable):
```rust
content = content.replace("\n", ""); // remove any line feed chars
content = content.replace("</tr>", "\n"); // replace any <tr> with a line feed.
```

### 4.3 split() and lines()
See the following code for `split()`:
```rust
let cells: Vec<&str> = tableline.split("</td>").collect();
```
The `split("</td/>")` followed by `collect()` returns a Vec of &str, representing all the cells of one row of the table, over which we will iterate:
```rust
for cell in cells {
    ...
```

`lines()` is a sepcialized version of `split` which splits a String with the '\n' linefeed char:
```rust
let tablelines = content.lines();
```
Here, we do not use `collect()`: `tablelines` is of type `Lines<'_>`, which implements the Iterator trait, so we shall directly use this iterator:

```rust
for tableline in tablelines {
   ...
}
```

### 4.4 Regular expressions

I use a regular expression to parse the `<td>` tag, for the case when the tag contains attributes such as `<td class="xx">`:
```rust
use regex::Regex;

let re = Regex::new(r"<td[^>]*>(.*)$").unwrap(); // line 110
```
Remember, we eliminated the `</td>` at the end of the html cell. Now we need to eliminate the <td ...> part at the beginning of the cell.

The regex reads as follows:
- after reading the initial part <td , read any character that is not a '>' : `[^>]*`
- until you reach a '>' character,
- then read all chars until the end $, and put them in one group (.*). This group will contain the content of the html cell.

We can use unwrap() safely here because we are sure of our regex syntax.

Then we use this group `(.*)` with the Regex `captures()` function. The capture with index 0 represents the total string. The cell content is the capture at index 1:

```rust
if let Some(caps) = re.captures(cell) { // destructuring the captures
    if caps.len() == 2 {
        line.push_str(&caps[1]); // push cell text to line
```
